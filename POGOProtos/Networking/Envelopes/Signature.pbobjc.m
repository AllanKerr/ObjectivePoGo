// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: POGOProtos/Networking/Envelopes/Signature.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "POGOProtos/Networking/Envelopes/Signature.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - SignatureRoot

@implementation SignatureRoot

@end

#pragma mark - SignatureRoot_FileDescriptor

static GPBFileDescriptor *SignatureRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"POGOProtos.Networking.Envelopes"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Signature

@implementation Signature

@dynamic timestampSinceStart;
@dynamic locationFixArray, locationFixArray_Count;
@dynamic hasGpsInfo, gpsInfo;
@dynamic hasSensorInfo, sensorInfo;
@dynamic hasDeviceInfo, deviceInfo;
@dynamic hasActivityStatus, activityStatus;
@dynamic locationHash1;
@dynamic locationHash2;
@dynamic sessionHash;
@dynamic timestamp;
@dynamic requestHashArray, requestHashArray_Count;
@dynamic unknown25;

typedef struct Signature__storage_ {
  uint32_t _has_storage_[1];
  uint32_t locationHash1;
  uint32_t locationHash2;
  NSMutableArray *locationFixArray;
  Signature_AndroidGpsInfo *gpsInfo;
  Signature_SensorInfo *sensorInfo;
  Signature_DeviceInfo *deviceInfo;
  Signature_ActivityStatus *activityStatus;
  NSData *sessionHash;
  GPBUInt64Array *requestHashArray;
  uint64_t timestampSinceStart;
  uint64_t timestamp;
  int64_t unknown25;
} Signature__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestampSinceStart",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_TimestampSinceStart,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature__storage_, timestampSinceStart),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "locationFixArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_LocationFix),
        .number = Signature_FieldNumber_LocationFixArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, locationFixArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gpsInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_AndroidGpsInfo),
        .number = Signature_FieldNumber_GpsInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature__storage_, gpsInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sensorInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_SensorInfo),
        .number = Signature_FieldNumber_SensorInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature__storage_, sensorInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_DeviceInfo),
        .number = Signature_FieldNumber_DeviceInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature__storage_, deviceInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activityStatus",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature_ActivityStatus),
        .number = Signature_FieldNumber_ActivityStatus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature__storage_, activityStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationHash1",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_LocationHash1,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Signature__storage_, locationHash1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "locationHash2",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_LocationHash2,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Signature__storage_, locationHash2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionHash",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_SessionHash,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Signature__storage_, sessionHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Timestamp,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Signature__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "requestHashArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_RequestHashArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature__storage_, requestHashArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "unknown25",
        .dataTypeSpecific.className = NULL,
        .number = Signature_FieldNumber_Unknown25,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature__storage_, unknown25),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature class]
                                     rootClass:[SignatureRoot class]
                                          file:SignatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_LocationFix

@implementation Signature_LocationFix

@dynamic provider;
@dynamic timestampSnapshot;
@dynamic altitude;
@dynamic latitude;
@dynamic longitude;
@dynamic speed;
@dynamic course;
@dynamic horizontalAccuracy;
@dynamic verticalAccuracy;
@dynamic providerStatus;
@dynamic floor;
@dynamic locationType;

typedef struct Signature_LocationFix__storage_ {
  uint32_t _has_storage_[1];
  float altitude;
  float latitude;
  float longitude;
  float speed;
  float course;
  float horizontalAccuracy;
  float verticalAccuracy;
  uint32_t floor;
  NSString *provider;
  uint64_t timestampSnapshot;
  uint64_t providerStatus;
  uint64_t locationType;
} Signature_LocationFix__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Provider,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestampSnapshot",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_TimestampSnapshot,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, timestampSnapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "altitude",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Altitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, altitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Latitude,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Longitude,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Speed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "course",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Course,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, course),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "horizontalAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_HorizontalAccuracy,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, horizontalAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "verticalAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_VerticalAccuracy,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, verticalAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "providerStatus",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_ProviderStatus,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, providerStatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "floor",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_Floor,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, floor),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "locationType",
        .dataTypeSpecific.className = NULL,
        .number = Signature_LocationFix_FieldNumber_LocationType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Signature_LocationFix__storage_, locationType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_LocationFix class]
                                     rootClass:[SignatureRoot class]
                                          file:SignatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_LocationFix__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_AndroidGpsInfo

@implementation Signature_AndroidGpsInfo

@dynamic timeToFix;
@dynamic satellitesPrnArray, satellitesPrnArray_Count;
@dynamic azimuthArray, azimuthArray_Count;
@dynamic elevationArray, elevationArray_Count;
@dynamic snrArray, snrArray_Count;
@dynamic hasAlmanacArray, hasAlmanacArray_Count;
@dynamic hasEphemerisArray, hasEphemerisArray_Count;
@dynamic usedInFixArray, usedInFixArray_Count;

typedef struct Signature_AndroidGpsInfo__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *satellitesPrnArray;
  GPBFloatArray *azimuthArray;
  GPBFloatArray *elevationArray;
  GPBFloatArray *snrArray;
  GPBBoolArray *hasAlmanacArray;
  GPBBoolArray *hasEphemerisArray;
  GPBBoolArray *usedInFixArray;
  uint64_t timeToFix;
} Signature_AndroidGpsInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeToFix",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_TimeToFix,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, timeToFix),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "satellitesPrnArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_SatellitesPrnArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, satellitesPrnArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "azimuthArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_AzimuthArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, azimuthArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "elevationArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_ElevationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, elevationArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "snrArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_SnrArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, snrArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "hasAlmanacArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_HasAlmanacArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, hasAlmanacArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "hasEphemerisArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_HasEphemerisArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, hasEphemerisArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "usedInFixArray",
        .dataTypeSpecific.className = NULL,
        .number = Signature_AndroidGpsInfo_FieldNumber_UsedInFixArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Signature_AndroidGpsInfo__storage_, usedInFixArray),
        .flags = GPBFieldRepeated | GPBFieldPacked,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_AndroidGpsInfo class]
                                     rootClass:[SignatureRoot class]
                                          file:SignatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_AndroidGpsInfo__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_SensorInfo

@implementation Signature_SensorInfo

@dynamic timestampSnapshot;
@dynamic linearAccelerationX;
@dynamic linearAccelerationY;
@dynamic linearAccelerationZ;
@dynamic magneticFieldX;
@dynamic magneticFieldY;
@dynamic magneticFieldZ;
@dynamic rotationVectorX;
@dynamic rotationVectorY;
@dynamic rotationVectorZ;
@dynamic gyroscopeRawX;
@dynamic gyroscopeRawY;
@dynamic gyroscopeRawZ;
@dynamic gravityX;
@dynamic gravityY;
@dynamic gravityZ;
@dynamic accelerometerAxes;

typedef struct Signature_SensorInfo__storage_ {
  uint32_t _has_storage_[1];
  uint64_t timestampSnapshot;
  double linearAccelerationX;
  double linearAccelerationY;
  double linearAccelerationZ;
  double magneticFieldX;
  double magneticFieldY;
  double magneticFieldZ;
  double rotationVectorX;
  double rotationVectorY;
  double rotationVectorZ;
  double gyroscopeRawX;
  double gyroscopeRawY;
  double gyroscopeRawZ;
  double gravityX;
  double gravityY;
  double gravityZ;
  uint64_t accelerometerAxes;
} Signature_SensorInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestampSnapshot",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_TimestampSnapshot,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, timestampSnapshot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "linearAccelerationX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_LinearAccelerationX,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, linearAccelerationX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "linearAccelerationY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_LinearAccelerationY,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, linearAccelerationY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "linearAccelerationZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_LinearAccelerationZ,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, linearAccelerationZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "magneticFieldX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_MagneticFieldX,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, magneticFieldX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "magneticFieldY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_MagneticFieldY,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, magneticFieldY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "magneticFieldZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_MagneticFieldZ,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, magneticFieldZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "rotationVectorX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_RotationVectorX,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, rotationVectorX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "rotationVectorY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_RotationVectorY,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, rotationVectorY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "rotationVectorZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_RotationVectorZ,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, rotationVectorZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gyroscopeRawX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GyroscopeRawX,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gyroscopeRawX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gyroscopeRawY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GyroscopeRawY,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gyroscopeRawY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gyroscopeRawZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GyroscopeRawZ,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gyroscopeRawZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gravityX",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GravityX,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gravityX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gravityY",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GravityY,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gravityY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gravityZ",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_GravityZ,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, gravityZ),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "accelerometerAxes",
        .dataTypeSpecific.className = NULL,
        .number = Signature_SensorInfo_FieldNumber_AccelerometerAxes,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Signature_SensorInfo__storage_, accelerometerAxes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_SensorInfo class]
                                     rootClass:[SignatureRoot class]
                                          file:SignatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_SensorInfo__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_DeviceInfo

@implementation Signature_DeviceInfo

@dynamic deviceId;
@dynamic androidBoardName;
@dynamic androidBootloader;
@dynamic deviceBrand;
@dynamic deviceModel;
@dynamic deviceModelIdentifier;
@dynamic deviceModelBoot;
@dynamic hardwareManufacturer;
@dynamic hardwareModel;
@dynamic firmwareBrand;
@dynamic firmwareTags;
@dynamic firmwareType;
@dynamic firmwareFingerprint;

typedef struct Signature_DeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceId;
  NSString *androidBoardName;
  NSString *androidBootloader;
  NSString *deviceBrand;
  NSString *deviceModel;
  NSString *deviceModelIdentifier;
  NSString *deviceModelBoot;
  NSString *hardwareManufacturer;
  NSString *hardwareModel;
  NSString *firmwareBrand;
  NSString *firmwareTags;
  NSString *firmwareType;
  NSString *firmwareFingerprint;
} Signature_DeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidBoardName",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_AndroidBoardName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, androidBoardName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidBootloader",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_AndroidBootloader,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, androidBootloader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceBrand",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceBrand,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceBrand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceModel,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModelIdentifier",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceModelIdentifier,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceModelIdentifier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModelBoot",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_DeviceModelBoot,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, deviceModelBoot),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareManufacturer",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_HardwareManufacturer,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, hardwareManufacturer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareModel",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_HardwareModel,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, hardwareModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareBrand",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareBrand,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareBrand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareTags",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareTags,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareTags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareType",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareFingerprint",
        .dataTypeSpecific.className = NULL,
        .number = Signature_DeviceInfo_FieldNumber_FirmwareFingerprint,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Signature_DeviceInfo__storage_, firmwareFingerprint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_DeviceInfo class]
                                     rootClass:[SignatureRoot class]
                                          file:SignatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_DeviceInfo__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Signature_ActivityStatus

@implementation Signature_ActivityStatus

@dynamic startTimeMs;
@dynamic unknownStatus;
@dynamic walking;
@dynamic running;
@dynamic stationary;
@dynamic automotive;
@dynamic tilting;
@dynamic cycling;
@dynamic status;
@dynamic bool10;

typedef struct Signature_ActivityStatus__storage_ {
  uint32_t _has_storage_[1];
} Signature_ActivityStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startTimeMs",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_StartTimeMs,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "unknownStatus",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_UnknownStatus,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "walking",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Walking,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "running",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Running,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "stationary",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Stationary,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "automotive",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Automotive,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "tilting",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Tilting,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "cycling",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Cycling,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Status,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bool10",
        .dataTypeSpecific.className = NULL,
        .number = Signature_ActivityStatus_FieldNumber_Bool10,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Signature_ActivityStatus class]
                                     rootClass:[SignatureRoot class]
                                          file:SignatureRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Signature_ActivityStatus__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
